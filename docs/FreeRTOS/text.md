## 优先级反转

场景如下：此时现在有三个任务：优先级分别为：H M L也就是高中低。

T0: L运行，要访问共享资源，所以持有了一个信号量S
T1: M运行，L挂起
T2: H运行，抢占了M，但是H也需要访问共享资源，但是S没有被L释放，所以H被挂起等待了
T3：M优先级高于L，所以M开始执行

以上情况的时候，H要运行，就需要L释放S，还要等M运行完，系统的响应实时性下降

### 解决方案

一、优先级继承
大致原理是L在获取信号量的时候，如果有高优先级的线程也需要使用该信号量，则临时提升L的优先级，让其更快的执行并释放资源，释放后再恢复原来的优先级。

也就是在上面的T2时刻，系统检测到这种情况，会临时吧L提升至和H一样的优先级，此时，在H挂起等待的时候，L大于M，L运行，然后释放资源，于是H就可以运行了。

二、优先级天花板
大致原理就是当线程申请共享资源的时候，把该线程的优先级提升到可访问这个资源的所有线程中的最高优先级，这个优先级就是天花板优先级。
## 互斥量
互斥的信号量起始就是一个拥有优先级继承的二值信号量，所以互斥信号量不能用于中断服务函数中：
- 互斥量有优先级继承的机制，但中断不是任务，没有优先级，所以互斥量只用于任务中，而不是中断中
- 中断服务函数不会因为要等信号量就进入阻塞

## 如何合理的设置任务栈大小

可以先给任务设置比较大的任务栈，确保不会出现栈溢出，运行的时候可以调用一个uxTaskGetStackHighWaterMark库函数，这个函数可以查到任务使用了多少的栈空间，然后最后去修改，一般设置个1.5-2倍左右

## FreeRTOS里进程之间有哪些通信方式
### 消息队列
消息队列主要用于任务和任务之间、消息和任务之间。队列的本质是一个环形缓冲区。创建队列的时候就要指定队列的长度和大小，特点是先进先出。任何任务或者中断都可以向队列里读写数据。当任务向队列写数据时队列已满，或者读的时候队列空了，则会进入阻塞并加入到等待链表。基于队列，FreeRTOS实现了多种如互斥信号量，计数信号量，二值信号量等等。

### 信号量
信号量主要解决同步问题，来实现对共享资源的有序访问，信号量是基于队列的。但因为信号量不是用来传递数据的，所以这个队列就只有头。

### 事件标志
事件标志是一个布尔量。FreeRTOS定义了一个EventBits_t变量，发生某种事件的时候，某一位可以置1，来表示某一事件的发生。

### 任务通知
每个任务都有两个用于任务通知的数组，分别是任务通知数组和任务通知状态数组。这两个数组为任务控制块中的成员变量。

## FreeRTOS启动流程
1. 系统上电后，会调用复位函数Reset_Handle，然后调用__main来初始化堆栈，最后跳到C里面的main
2. main函数中各种系统初始化，创建任务，然后最后启动调度器vTaskStartScheduler
3. 调度器执行：
    - 创建空闲任务，定时器服务关闭，中断关闭
    - 设置PendSV和Systick为最低优先级中断，打开Systick中断，执行各种初始化
    - 最后调用vPortStartFirstTask函数，通过SVC中断来启动第一个任务，SVC中断也就执行这一次。

## 什么是任务控制块
任务控制块是一个结构体，来保存任务的属性、信息之类的，比如堆栈指针、优先级、栈空间起始地址等。

## 什么是临界区和临界资源
临界区是那些必须完整运行的代码，不能被打断。临界资源就是临界区中的共享资源，比如消息队列等等。

## 什么是任务死锁
死锁就是两个线程互相等待对方释放资源，比如：

任务A和B，都会访问两个共享资源X,Y,A获取了X，B获取了Y，然后A获取Y的时候，B没释放所以A阻塞了等待B,B运行的时候又要获取X，又阻塞了，两个就死了。

发生任务死锁要同时满足：
1. 互斥：多个任务不能同时获取同一共享资源
2. 持有并等待条件：任务会因为等待获取资源而进入阻塞等待，并且不会放弃自己已经持有的资源
3. 不可剥夺条件：任务获取资源后，只能自己释放，没其他方法
4. 环路等待

## MSP 和 PSP指针